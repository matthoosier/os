#include <assert.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>

#include <list>

#include <muos/array.h>
#include <muos/bits.h>
#include <muos/compiler.h>
#include <muos/error.h>
#include <muos/io.h>
#include <muos/message.h>
#include <muos/naming.h>
#include <muos/process.h>

#include "uart.h"

#define VERSATILE_UART0_BASE    0x101F1000
#define VERSATILE_UART0_IRQ     12
#define PL011_MMAP_SIZE         4096

typedef struct
{
    uint32_t        DR;         /* Offset 0x000 */
    uint32_t        SR;         /* Offset 0x004 */
    uint32_t        reserved1;  /* Offset 0x008 */
    uint32_t        reserved2;  /* Offset 0x00c */
    uint32_t        reserved3;  /* Offset 0x010 */
    uint32_t        reserved4;  /* Offset 0x014 */
    uint32_t const  FR;         /* Offset 0x018 */
    uint32_t        reserved5;  /* Offset 0x01c */
    uint32_t        ILPR;       /* Offset 0x020 */
    uint32_t        IBRD;       /* Offset 0x024 */
    uint32_t        FBRD;       /* Offset 0x028 */
    uint32_t        LCR_H;      /* Offset 0x02C */
    uint32_t        CR;         /* Offset 0x030 */
    uint32_t        IFLS;       /* Offset 0x034 */
    uint32_t        IMSC;       /* Offset 0x038 */
    uint32_t const  RIS;        /* Offset 0x03C */
    uint32_t const  MIS;        /* Offset 0x040 */
    uint32_t        ICR;        /* Offset 0x044 */
    uint32_t        DMACR;      /* Offset 0x048 */
} pl011_t;

COMPILER_ASSERT(sizeof(pl011_t) == (0x048 + 4));

enum
{
    /**
     * \brief   Receive Fifo Empty
     *
     * Bit in FR register which, when set, says that there are not
     * bytes available to read.
     */
    FR_RXFE = SETBIT(4),

    /**
     * \brief   Transmit Fifo Full
     *
     * Bit in FR register which, when set, says that the output
     * pipeline is full.
     */
    FR_TXFF = SETBIT(5),
};

enum
{
    /**
     * \brief   Transmit enabled
     */
    CR_TXE = SETBIT(8),

    /**
     * \brief   Receive enabled
     */
    CR_RXE = SETBIT(9),

    /**
     * \brief   UART enabled
     */
    CR_UARTEN = SETBIT(0),
};

enum
{
    /**
     * \brief   Receive interrupt masked
     */
    IMSC_RX = SETBIT(4),

    /**
     * \brief   Transmit interrupt masked
     */
    IMSC_TX = SETBIT(5),
};

enum
{
    /**
     * \brief   Receive interrupt is high
     */
    MIS_RX = SETBIT(4),

    /**
     * \brief   Transmit interrupt is high
     */
    MIS_TX = SETBIT(5),
};

enum
{
    /**
     * \brief   Clear Receive interrupt
     */
    ICR_RX = SETBIT(4),

    /**
     * \brief   Clear Transmit interrupt
     */
    ICR_TX = SETBIT(5),

    /**
     * \brief   Clear all interrupts
     */
    ICR_ALL = 0x7ff,
};

static bool pl011_read_ready (pl011_t volatile * uart)
{
    return (uart->FR & FR_RXFE) == 0;
}

static uint8_t pl011_blocking_read (pl011_t volatile * uart)
{
    while (!pl011_read_ready(uart));
    return uart->DR;
}

static bool pl011_write_ready (pl011_t volatile * uart)
{
    return (uart->FR & FR_TXFF) == 0;
}

static void pl011_blocking_write (pl011_t volatile * uart, uint8_t c)
{
    while (!pl011_write_ready(uart));
    uart->DR = c;
}

static void pl011_printf (pl011_t volatile * uart,
                          const char format[],
                          ...)
{
    char buf[64];
    va_list list;
    int num;
    int i;

    va_start(list, format);
    vsnprintf(buf, sizeof(buf), format, list);
    va_end(list);

    num = strlen(buf);
    for (i = 0; i < num; ++i) {
        pl011_blocking_write(uart, buf[i]);
    }
}

char my_toupper (char c)
{
    if (c >= 'a' && c <= 'z') {
        return c + ('A' - 'a');
    }
    else if (c >= 'A' && c <= 'Z') {
        return c;
    }
    else if (c == '\r' || c == '\n') {
        return c;
    }
    else {
        return '?';
    }
}

class Read
{
public:
    int mMessageId;
    size_t const mLen;
    size_t mLenDone;
    uint8_t * mBuf;

    Read (int aMessageId, size_t size)
        : mMessageId(aMessageId)
        , mLen(size)
        , mLenDone(0)
    {
        mBuf = (uint8_t *)malloc(mLen);
    }

    ~Read ()
    {
        free(mBuf);
    }
};

std::list<Read *> gReads;
Read * gCurrentRead = NULL;

void pl011_isr (pl011_t volatile * uart, int irq_handler_id)
{
    uint32_t mis = uart->MIS;

    if (mis & MIS_TX) {
        /*
        The transmit interrupt generated by somebody sending.
        There's no real work to do here, so just clear it and move on.
        */
        uart->ICR = ICR_TX;
    }

    if (mis & MIS_RX) {
        while (pl011_read_ready(uart)) {
            uint8_t payload;

            payload = pl011_blocking_read(uart);

            if (!gCurrentRead && !gReads.empty()) {
                gCurrentRead = *gReads.begin();
                gReads.erase(gReads.begin());
            }
                
            if (gCurrentRead) {
                assert(gCurrentRead->mLen > gCurrentRead->mLenDone);
                gCurrentRead->mBuf[gCurrentRead->mLenDone] = payload;
                gCurrentRead->mLenDone++;

                if (gCurrentRead->mLenDone == gCurrentRead->mLen) {

                    struct iovec msg_parts[2];

                    UartReply reply;
                    reply.type = UART_MESSAGE_READ;
                    reply.payload.read.len = gCurrentRead->mLen;

                    msg_parts[0].iov_base = &reply;
                    msg_parts[0].iov_len = offsetof(UartReply, payload.read.buf);
                    msg_parts[1].iov_base = gCurrentRead->mBuf;
                    msg_parts[1].iov_len = gCurrentRead->mLen;

                    MessageReplyV(gCurrentRead->mMessageId,
                                  ERROR_OK,
                                  msg_parts,
                                  N_ELEMENTS(msg_parts));

                    delete gCurrentRead;
                    gCurrentRead = NULL;
                }
            }
        }
        uart->ICR = ICR_RX;
    }

    InterruptComplete(irq_handler_id);
}

#define MAX(_a, _b)     \
    ({                  \
    typeof(_a) a = _a;  \
    typeof(_b) b = _b;  \
    a > b ? a : b;      \
    })

#define MIN(_a, _b)     \
    ({                  \
    typeof(_a) a = _a;  \
    typeof(_b) b = _b;  \
    a < b ? a : b;      \
    })

int main (int argc, char *argv[]) {

    typedef union
    {
        struct Pulse async;
        UartMessage sync;
    } Msg_t;

    Msg_t msg;

    pl011_t volatile * uart0;
    int irq_handler_id;
    int chid;
    int coid;

    chid = NameAttach("/dev/uart");
    coid = Connect(SELF_PID, chid);

    Spawn("uio");
    Spawn("terminal");

    uart0 = (volatile pl011_t *)MapPhysical(VERSATILE_UART0_BASE, PL011_MMAP_SIZE);

    pl011_printf(uart0, "PL011 UART driver started up in echo mode...\n");

    // Clear all pending interrupts
    uart0->ICR = ICR_ALL;

    // Enable interrupts
    uart0->IMSC = (IMSC_RX | IMSC_TX);

    irq_handler_id = InterruptAttach(coid, VERSATILE_UART0_IRQ, NULL);

    // Main interrupt-handling loop
    for (;;) {
        int msgid;
        MessageReceive(chid, &msgid, &msg, sizeof(msg));

        if (msgid == 0) {
            // Pulse
            pl011_isr(uart0, irq_handler_id);
        }
        else {
            if (msg.sync.type == UART_MESSAGE_READ) {
                gReads.push_back(new Read(msgid, msg.sync.payload.read.len));
            }
            else if (msg.sync.type == UART_MESSAGE_WRITE) {
                for (size_t i = 0; i < msg.sync.payload.write.len; ++i) {
                    uint8_t b;
                    MessageRead(msgid, offsetof(UartMessage, payload.write.buf) + i, &b, sizeof(b));
                    pl011_blocking_write(uart0, b);
                }

                UartReply reply;
                reply.type = UART_MESSAGE_WRITE;
                reply.payload.write.len = msg.sync.payload.write.len;
                MessageReply(msgid, ERROR_OK, &reply, sizeof(reply));
            }
            else {
                pl011_printf(uart0, "Got unknown message\n");
                MessageReply(msgid, ERROR_NO_SYS, NULL, 0);
            }
        }
    }

    // Disable interrupts
    uart0->IMSC &= ~(IMSC_RX | IMSC_TX);

    InterruptDetach(irq_handler_id);

    while (true) {
        uint8_t c = pl011_blocking_read(uart0);
        pl011_blocking_write(uart0, my_toupper(c));
    }

    return 0;
}
